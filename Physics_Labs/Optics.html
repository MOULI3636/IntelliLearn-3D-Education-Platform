<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optics Simulator: Lenses & Prisms</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #ffffff;
            color: #2d5a2d;
            line-height: 1.6;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
        }
        
        .back-menu {
            position: absolute;
            top: 30px;
            right: 40px;
            padding: 8px 16px;
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            z-index: 10;
            width: auto;
            font-weight: bold;
        }

        .back-menu:hover {
            background-color: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: #ffffff;
            color: #4caf50;
            border-radius: 12px;
            border: 2px solid #4caf50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5), 
                        0 4px 12px rgba(76, 175, 80, 0.3);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #4caf50, #8bc34a, #4caf50);
            border-radius: 14px;
            z-index: -1;
            animation: glow 3s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                opacity: 0.7;
            }
            to {
                opacity: 1;
            }
        }
        
        h1 {
            margin-bottom: 10px;
            font-size: 2.2rem;
        }
        
        .description {
            margin-bottom: 20px;
            font-size: 1.1rem;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            color: #2d5a2d;
        }
        
        .tab-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 12px 24px;
            background-color: #f1f8e9;
            border: 2px solid #4caf50;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            margin: 0 5px;
            color: #2d5a2d;
        }
        
        .tab.active {
            background-color: #4caf50;
            color: #ffffff;
        }
        
        .simulator-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .simulator {
            flex: 1;
            min-width: 300px;
            background-color: #fff;
            border: 2px solid #4caf50;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.4);
        }
        
        .simulator h2 {
            text-align: center;
            color: #4caf50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f1f8e9;
        }
        
        canvas {
            display: block;
            margin: 0 auto;
            border: 1px solid #8bc34a;
            background-color: #f9f9f9;
            border-radius: 8px;
        }
        
        .control-panel {
            background-color: #f1f8e9;
            border: 2px solid #4caf50;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.4);
            border-radius: 12px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2d5a2d;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: #4caf50;
        }
        
        .control-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #4caf50;
            border-radius: 5px;
            background-color: #f1f8e9;
            color: #2d5a2d;
        }
        
        .value-display {
            color: #4caf50;
            font-weight: bold;
        }
        
        button {
            padding: 10px 15px;
            border: none;
            background-color: #4caf50;
            color: #ffffff;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            margin-top: 10px;
            width: 100%;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        .info-panel {
            margin-top: 15px;
            padding: 15px;
            background: #f1f8e9;
            border-radius: 8px;
            border-left: 5px solid #4caf50;
        }
        
        .info-panel p {
            margin: 5px 0;
            font-size: 15px;
        }
        
        .info-panel strong {
            color: #4caf50;
        }
        
        .hidden {
            display: none;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(45, 90, 45, 0.8);
        }
        
        .modal-content {
            background-color: #f1f8e9;
            margin: 5% auto;
            padding: 30px;
            border: 2px solid #4caf50;
            border-radius: 12px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .close {
            color: #4caf50;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover {
            color: #2d5a2d;
        }
        
        .theory-content h3 {
            color: #4caf50;
            margin: 20px 0 10px;
            border-bottom: 1px solid #8bc34a;
            padding-bottom: 5px;
        }
        
        .theory-content p {
            margin-bottom: 15px;
            line-height: 1.6;
        }
        
        .theory-content ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        
        .theory-content li {
            margin-bottom: 8px;
        }
        
        .theory-content .formula {
            background-color: #e8f5e9;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #4caf50;
            font-style: italic;
        }
        
        @media (max-width: 768px) {
            .simulator-container {
                flex-direction: column;
            }
            
            .modal-content {
                width: 95%;
                margin: 10% auto;
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <!-- <button class="back-menu">Back Menu</button> -->
    
    <header>
        <h1>Optics Simulator: Lenses & Prisms</h1>
        <p class="description">Explore how light behaves with different optical elements. Adjust parameters to see real-time changes in light paths and image formation.</p>
    </header>
    
    <div class="tab-container">
        <div class="tab active" data-tab="lens">Lens Simulator</div>
        <div class="tab" data-tab="prism">Prism Simulator</div>
    </div>
    
    <div id="lens-simulator" class="simulator">
        <h2>Lens Simulator üî≠</h2>
        <canvas id="lensCanvas" width="600" height="400"></canvas>
        
        <div class="control-panel">
            <div class="control-group">
                <label for="lensType">Lens Type:</label>
                <select id="lensType">
                    <option value="convex" selected>Convex Lens</option>
                    <option value="concave">Concave Lens</option>
                </select>
            </div>

            <div class="control-group">
                <label for="objectPosition">Object Position (u): <span id="objectPositionValue" class="value-display"></span> px</label>
                <input type="range" id="objectPosition" min="10" max="390" value="200">
            </div>

            <div class="control-group">
                <label for="focalLength">Focal Length (f): <span id="focalLengthValue" class="value-display"></span> px</label>
                <input type="range" id="focalLength" min="50" max="150" value="100">
            </div>

            <div class="control-group">
                <label for="objectHeight">Object Height (h‚Çí): <span id="objectHeightValue" class="value-display"></span> px</label>
                <input type="range" id="objectHeight" min="10" max="100" value="50">
            </div>
            
            <button id="resetLensButton">Reset Lens Simulation</button>
            <button id="theoryLensButton">Lens Theory</button>
        </div>
        
        <div class="info-panel">
            <p><strong>Image Distance (v):</strong> <span id="imageDistance"></span></p>
            <p><strong>Image Height (h·µ¢):</strong> <span id="imageHeight"></span></p>
            <p><strong>Magnification (m):</strong> <span id="magnification"></span></p>
            <p><strong>Nature of Image:</strong> <span id="imageNature"></span></p>
        </div>
    </div>
    
    <div id="prism-simulator" class="simulator hidden">
        <h2>Prism Simulator üåà</h2>
        <canvas id="prismCanvas" width="600" height="400"></canvas>
        
        <div class="control-panel">
            <div class="control-group">
                <label>Light Angle: <span id="angleValue" class="value-display">0¬∞</span></label>
                <input type="range" id="angleSlider" min="-60" max="60" step="1" value="25">
            </div>

            <div class="control-group">
                <label>Wavelength: <span id="colorValue" class="value-display">550 nm</span></label>
                <input type="range" id="colorSlider" min="380" max="780" step="1" value="550">
            </div>

            <div class="control-group">
                <label>Refractive Index: <span id="iorValue" class="value-display">1.5</span></label>
                <input type="range" id="iorSlider" min="1.3" max="2.0" step="0.01" value="1.5">
            </div>
            
            <button id="resetPrismButton">Reset Prism Simulation</button>
            <button id="theoryPrismButton">Prism Theory</button>
        </div>
        
        <div class="info-panel">
            <p><strong>Status:</strong> <span id="statusMessage">Waiting for interaction...</span></p>
            <p><strong>Prism Properties:</strong> Equilateral triangle with 60¬∞ angles</p>
            <p><strong>Light Behavior:</strong> Refraction and dispersion</p>
        </div>
    </div>

    <!-- Theory Modals -->
    <div id="lensTheoryModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div class="theory-content">
                <h2>Lens Theory: How Lenses Work</h2>
                
                <h3>Introduction to Lenses</h3>
                <p>Lenses are transparent optical components with curved surfaces that refract light. They are typically made of glass or plastic and are used to focus or diverge light beams. Lenses work based on the principle of refraction - the bending of light as it passes from one medium to another.</p>
                
                <h3>Types of Lenses</h3>
                <p>There are two main types of lenses:</p>
                <ul>
                    <li><strong>Convex (Converging) Lenses:</strong> These lenses are thicker in the middle than at the edges. They cause parallel light rays to converge to a point called the focal point.</li>
                    <li><strong>Concave (Diverging) Lenses:</strong> These lenses are thinner in the middle than at the edges. They cause parallel light rays to diverge as if they originated from a focal point.</li>
                </ul>
                
                <h3>Key Terminology</h3>
                <ul>
                    <li><strong>Optical Center:</strong> The geometric center of a lens where light passes through without deviation.</li>
                    <li><strong>Principal Axis:</strong> The horizontal line passing through the optical center of the lens.</li>
                    <li><strong>Focal Point (F):</strong> The point where parallel rays of light converge (convex lens) or appear to diverge from (concave lens).</li>
                    <li><strong>Focal Length (f):</strong> The distance between the optical center and the focal point.</li>
                    <li><strong>Object Distance (u):</strong> The distance between the object and the lens.</li>
                    <li><strong>Image Distance (v):</strong> The distance between the image and the lens.</li>
                </ul>
                
                <h3>The Lens Formula</h3>
                <div class="formula">
                    1/f = 1/v - 1/u
                </div>
                <p>Where:<br>
                f = focal length<br>
                v = image distance<br>
                u = object distance (negative according to sign convention)</p>
                
                <h3>Magnification</h3>
                <div class="formula">
                    m = h·µ¢/h‚Çí = v/u
                </div>
                <p>Where:<br>
                m = magnification<br>
                h·µ¢ = image height<br>
                h‚Çí = object height</p>
                
                <h3>Image Formation in Convex Lenses</h3>
                <p>Depending on the object position, convex lenses can form different types of images:</p>
                <ul>
                    <li><strong>Object beyond 2F:</strong> Real, inverted, diminished image between F and 2F</li>
                    <li><strong>Object at 2F:</strong> Real, inverted, same size image at 2F</li>
                    <li><strong>Object between F and 2F:</strong> Real, inverted, magnified image beyond 2F</li>
                    <li><strong>Object at F:</strong> Image at infinity</li>
                    <li><strong>Object between F and lens:</strong> Virtual, erect, magnified image on the same side as the object</li>
                </ul>
                
                <h3>Image Formation in Concave Lenses</h3>
                <p>Concave lenses always form virtual, erect, and diminished images regardless of the object position. The image appears between the focal point and the lens on the same side as the object.</p>
                
                <h3>Real-World Applications</h3>
                <ul>
                    <li><strong>Convex Lenses:</strong> Used in cameras, magnifying glasses, microscopes, telescopes, and human eyes</li>
                    <li><strong>Concave Lenses:</strong> Used in eyeglasses for nearsightedness, peepholes, and laser beam expanders</li>
                </ul>
            </div>
        </div>
    </div>

    <div id="prismTheoryModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div class="theory-content">
                <h2>Prism Theory: Refraction and Dispersion</h2>
                
                <h3>Introduction to Prisms</h3>
                <p>A prism is a transparent optical element with flat, polished surfaces that refract light. The most common type is the triangular prism, which has triangular bases and rectangular sides. Prisms can be made from glass, plastic, or other transparent materials.</p>
                
                <h3>Refraction in Prisms</h3>
                <p>When light enters a prism, it undergoes refraction (bending) at both surfaces. The amount of bending depends on:</p>
                <ul>
                    <li>The angle of incidence</li>
                    <li>The refractive index of the prism material</li>
                    <li>The wavelength of light (causing dispersion)</li>
                </ul>
                
                <h3>Snell's Law</h3>
                <p>The refraction of light at the interface between two media is governed by Snell's Law:</p>
                <div class="formula">
                    n‚ÇÅsin(Œ∏‚ÇÅ) = n‚ÇÇsin(Œ∏‚ÇÇ)
                </div>
                <p>Where:<br>
                n‚ÇÅ = refractive index of first medium<br>
                Œ∏‚ÇÅ = angle of incidence<br>
                n‚ÇÇ = refractive index of second medium<br>
                Œ∏‚ÇÇ = angle of refraction</p>
                
                <h3>Dispersion of Light</h3>
                <p>One of the most important properties of prisms is their ability to disperse white light into its constituent colors. This happens because:</p>
                <ul>
                    <li>Different wavelengths (colors) of light travel at different speeds in a medium</li>
                    <li>The refractive index of a material varies with wavelength (called chromatic dispersion)</li>
                    <li>Shorter wavelengths (blue/violet) bend more than longer wavelengths (red)</li>
                </ul>
                
                <h3>The Visible Spectrum</h3>
                <p>When white light passes through a prism, it separates into the colors of the visible spectrum:</p>
                <ul>
                    <li><strong>Violet:</strong> 380-450 nm</li>
                    <li><strong>Blue:</strong> 450-495 nm</li>
                    <li><strong>Green:</strong> 495-570 nm</li>
                    <li><strong>Yellow:</strong> 570-590 nm</li>
                    <li><strong>Orange:</strong> 590-620 nm</li>
                    <li><strong>Red:</strong> 620-750 nm</li>
                </ul>
                
                <h3>Angle of Minimum Deviation</h3>
                <p>For a prism, there is a particular angle of incidence that produces the smallest angle of deviation between the incident and emergent rays. This is called the angle of minimum deviation and is given by:</p>
                <div class="formula">
                    n = sin[(A + Œ¥‚Çò)/2] / sin(A/2)
                </div>
                <p>Where:<br>
                n = refractive index<br>
                A = angle of prism<br>
                Œ¥‚Çò = angle of minimum deviation</p>
                
                <h3>Total Internal Reflection</h3>
                <p>When light attempts to move from a medium with higher refractive index to one with lower refractive index, beyond a certain critical angle, all light is reflected back into the original medium. This phenomenon is used in many types of prisms.</p>
                
                <h3>Types of Prisms and Their Applications</h3>
                <ul>
                    <li><strong>Dispersion Prisms:</strong> Used in spectrometers to separate light into its component wavelengths</li>
                    <li><strong>Reflective Prisms:</strong> Used to alter the direction of light in optical instruments like binoculars and periscopes</li>
                    <li><strong>Polarizing Prisms:</strong> Used to separate light waves with different polarization states</li>
                    <li><strong>Beam-Splitting Prisms:</strong> Used to divide a light beam into two or more separate beams</li>
                </ul>
                
                <h3>Real-World Examples</h3>
                <ul>
                    <li>Rainbows (natural prism effect by water droplets)</li>
                    <li>Spectrometers for chemical analysis</li>
                    <li>Binoculars and cameras using Porro prisms</li>
                    <li>Retroreflectors in road signs and bicycle reflectors</li>
                    <li>Optical communications systems</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Tab functionality
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                document.getElementById('lens-simulator').classList.add('hidden');
                document.getElementById('prism-simulator').classList.add('hidden');
                
                document.getElementById(tab.dataset.tab + '-simulator').classList.remove('hidden');
            });
        });

        // Modal functionality
        const lensTheoryModal = document.getElementById('lensTheoryModal');
        const prismTheoryModal = document.getElementById('prismTheoryModal');
        const closeButtons = document.querySelectorAll('.close');
        
        document.getElementById('theoryLensButton').addEventListener('click', () => {
            lensTheoryModal.style.display = 'block';
        });
        
        document.getElementById('theoryPrismButton').addEventListener('click', () => {
            prismTheoryModal.style.display = 'block';
        });
        
        closeButtons.forEach(button => {
            button.addEventListener('click', () => {
                lensTheoryModal.style.display = 'none';
                prismTheoryModal.style.display = 'none';
            });
        });
        
        window.addEventListener('click', (event) => {
            if (event.target == lensTheoryModal) {
                lensTheoryModal.style.display = 'none';
            }
            if (event.target == prismTheoryModal) {
                prismTheoryModal.style.display = 'none';
            }
        });

        // Lens Simulator
        document.addEventListener('DOMContentLoaded', () => {
            const lensCanvas = document.getElementById('lensCanvas');
            const lensCtx = lensCanvas.getContext('2d');
            const centerX = lensCanvas.width / 2;
            const centerY = lensCanvas.height / 2;

            const lensTypeSelect = document.getElementById('lensType');
            const objectPositionSlider = document.getElementById('objectPosition');
            const focalLengthSlider = document.getElementById('focalLength');
            const objectHeightSlider = document.getElementById('objectHeight');
            const resetLensButton = document.getElementById('resetLensButton');

            const objectPositionValue = document.getElementById('objectPositionValue');
            const focalLengthValue = document.getElementById('focalLengthValue');
            const objectHeightValue = document.getElementById('objectHeightValue');
            
            const imageDistanceEl = document.getElementById('imageDistance');
            const imageHeightEl = document.getElementById('imageHeight');
            const magnificationEl = document.getElementById('magnification');
            const imageNatureEl = document.getElementById('imageNature');

            let lensConfig = {
                lensType: 'convex',
                objectDistanceU: -200,
                focalLengthF: 100,
                objectHeightHo: 50
            };
            
            const defaultLensValues = {
                lensType: 'convex',
                objectDistanceU: -200,
                focalLengthF: 100,
                objectHeightHo: 50
            };

            function drawPrincipalAxis() {
                lensCtx.beginPath();
                lensCtx.moveTo(0, centerY);
                lensCtx.lineTo(lensCanvas.width, centerY);
                lensCtx.strokeStyle = '#2d5a2d';
                lensCtx.lineWidth = 1;
                lensCtx.stroke();
            }

            function drawLens() {
                lensCtx.beginPath();
                lensCtx.strokeStyle = '#4caf50';
                lensCtx.lineWidth = 4;
                if (lensConfig.lensType === 'convex') {
                    lensCtx.moveTo(centerX, centerY - 80);
                    lensCtx.quadraticCurveTo(centerX + 40, centerY, centerX, centerY + 80);
                    lensCtx.moveTo(centerX, centerY - 80);
                    lensCtx.quadraticCurveTo(centerX - 40, centerY, centerX, centerY + 80);
                } else {
                    lensCtx.moveTo(centerX - 15, centerY - 80);
                    lensCtx.lineTo(centerX - 15, centerY + 80);
                    lensCtx.moveTo(centerX + 15, centerY - 80);
                    lensCtx.lineTo(centerX + 15, centerY + 80);
                    lensCtx.moveTo(centerX - 15, centerY - 80);
                    lensCtx.lineTo(centerX + 15, centerY - 80);
                    lensCtx.moveTo(centerX - 15, centerY + 80);
                    lensCtx.lineTo(centerX + 15, centerY + 80);
                }
                lensCtx.stroke();
                
                // Draw center/mirror line
                lensCtx.beginPath();
                lensCtx.moveTo(centerX, centerY - 90);
                lensCtx.lineTo(centerX, centerY + 90);
                lensCtx.strokeStyle = 'rgba(45, 90, 45, 0.3)';
                lensCtx.setLineDash([5, 3]);
                lensCtx.lineWidth = 1;
                lensCtx.stroke();
                lensCtx.setLineDash([]);
            }

            function drawFocalPoints() {
                const f = lensConfig.focalLengthF;
                // F1 and 2F1
                lensCtx.fillStyle = '#2d5a2d';
                lensCtx.fillText('2F‚ÇÅ', centerX - 2 * f - 12, centerY + 15);
                lensCtx.fillRect(centerX - 2 * f - 1, centerY - 3, 2, 6);
                lensCtx.fillText('F‚ÇÅ', centerX - f - 8, centerY + 15);
                lensCtx.fillRect(centerX - f - 1, centerY - 3, 2, 6);
                // F2 and 2F2
                lensCtx.fillText('F‚ÇÇ', centerX + f - 8, centerY + 15);
                lensCtx.fillRect(centerX + f - 1, centerY - 3, 2, 6);
                lensCtx.fillText('2F‚ÇÇ', centerX + 2 * f - 12, centerY + 15);
                lensCtx.fillRect(centerX + 2 * f - 1, centerY - 3, 2, 6);
            }

            function drawArrow(fromX, fromY, toX, toY, color) {
                const headlen = 10;
                const angle = Math.atan2(toY - fromY, toX - fromX);
                lensCtx.beginPath();
                lensCtx.moveTo(fromX, fromY);
                lensCtx.lineTo(toX, toY);
                lensCtx.strokeStyle = color;
                lensCtx.lineWidth = 2;
                lensCtx.stroke();
                lensCtx.beginPath();
                lensCtx.moveTo(toX, toY);
                lensCtx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
                lensCtx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
                lensCtx.lineTo(toX, toY);
                lensCtx.fillStyle = color;
                lensCtx.fill();
            }
            
            function drawDashedLine(x1, y1, x2, y2, color) {
                lensCtx.beginPath();
                lensCtx.setLineDash([5, 5]);
                lensCtx.moveTo(x1, y1);
                lensCtx.lineTo(x2, y2);
                lensCtx.strokeStyle = color;
                lensCtx.lineWidth = 1;
                lensCtx.stroke();
                lensCtx.setLineDash([]);
            }

            function drawLensSimulation() {
                lensCtx.clearRect(0, 0, lensCanvas.width, lensCanvas.height);
                lensCtx.font = '12px Arial';
                lensCtx.fillStyle = '#2d5a2d';

                drawPrincipalAxis();
                drawLens();
                drawFocalPoints();

                // Object
                const u = lensConfig.objectDistanceU;
                const f = lensConfig.focalLengthF;
                const ho = lensConfig.objectHeightHo;
                const objectX = centerX + u;
                drawArrow(objectX, centerY, objectX, centerY - ho, '#c44b23');
                lensCtx.fillText('Object', objectX - 15, centerY - ho - 10);

                // Lens formula: 1/v - 1/u = 1/f
                let v = 1 / (1 / f + 1 / u);
                
                // Magnification: m = hi/ho = v/u
                let magnification = v / u;
                let hi = ho * magnification;
                const imageX = centerX + v;

                // Rays
                // 1. Ray parallel to principal axis
                drawArrow(objectX, centerY - ho, centerX, centerY - ho, '#d68c23');
                if (lensConfig.lensType === 'convex') {
                    drawArrow(centerX, centerY - ho, imageX, centerY - hi, '#d68c23');
                    if (v < 0) {
                        drawDashedLine(centerX, centerY - ho, centerX - f, centerY, '#d68c23');
                    }
                } else {
                    drawArrow(centerX, centerY - ho, centerX + (lensCanvas.width/2), centerY - ho + (lensCanvas.width/2) * (ho/f), '#d68c23');
                    drawDashedLine(objectX-10, centerY-ho, centerX - f, centerY, '#d68c23');
                }

                // 2. Ray passing through optical center
                drawArrow(objectX, centerY - ho, centerX, centerY, '#2a8c55');
                drawArrow(centerX, centerY, imageX, centerY - hi, '#2a8c55');
                
                // 3. Ray through focus
                if (lensConfig.lensType === 'convex') {
                    drawArrow(objectX, centerY - ho, centerX - f, centerY, '#4caf50');
                    drawArrow(centerX - f, centerY, centerX, centerY - ho, '#4caf50');
                    drawArrow(centerX, centerY - ho, imageX, centerY - hi, '#4caf50');
                }

                // Image
                if (isFinite(v)) {
                    if(v/u < 0) {
                         drawArrow(imageX, centerY, imageX, centerY - hi, '#2c6b8b');
                         lensCtx.fillText('Image', imageX - 15, centerY - hi + (hi > 0 ? -10: 20));
                    } else {
                         lensCtx.globalAlpha = 0.7;
                         drawArrow(imageX, centerY, imageX, centerY - hi, '#2c6b8b');
                         lensCtx.globalAlpha = 1.0;
                         drawDashedLine(imageX, centerY-hi, objectX, centerY-ho, '#8bc34a');
                         lensCtx.fillText('Virtual Image', imageX - 25, centerY - hi - 10);
                    }
                }

                updateLensInfoPanel(u, v, hi, magnification);
            }

            function updateLensInfoPanel(u, v, hi, m) {
                objectPositionValue.textContent = -u.toFixed(0);
                focalLengthValue.textContent = Math.abs(lensConfig.focalLengthF).toFixed(0);
                objectHeightValue.textContent = lensConfig.objectHeightHo.toFixed(0);
                
                imageDistanceEl.textContent = isFinite(v) ? Math.abs(v).toFixed(2) + ' px' : 'Infinity';
                imageHeightEl.textContent = isFinite(hi) ? Math.abs(hi).toFixed(2) + ' px' : 'N/A';
                magnificationEl.textContent = isFinite(m) ? m.toFixed(2) : 'N/A';
                
                let nature = '';
                if (isFinite(v)) {
                    nature += (v > 0) ? 'Real, ' : 'Virtual, ';
                    nature += (m < 0) ? 'Inverted, ' : 'Erect, ';
                    if (Math.abs(m) > 1) nature += 'Magnified';
                    else if (Math.abs(m) < 1) nature += 'Diminished';
                    else nature += 'Same Size';
                } else {
                    nature = "Image at Infinity";
                }
                imageNatureEl.textContent = nature;
            }

            function updateLensConfig() {
                lensConfig.lensType = lensTypeSelect.value;
                lensConfig.objectDistanceU = -parseFloat(objectPositionSlider.value);
                let fVal = parseFloat(focalLengthSlider.value);
                lensConfig.focalLengthF = (lensConfig.lensType === 'convex') ? fVal : -fVal;
                lensConfig.objectHeightHo = parseFloat(objectHeightSlider.value);
                drawLensSimulation();
            }
            
            function resetLensSimulation() {
                 lensTypeSelect.value = defaultLensValues.lensType;
                 objectPositionSlider.value = -defaultLensValues.objectDistanceU;
                 focalLengthSlider.value = Math.abs(defaultLensValues.focalLengthF);
                 objectHeightSlider.value = defaultLensValues.objectHeightHo;
                 updateLensConfig();
            }

            lensTypeSelect.addEventListener('change', updateLensConfig);
            objectPositionSlider.addEventListener('input', updateLensConfig);
            focalLengthSlider.addEventListener('input', updateLensConfig);
            objectHeightSlider.addEventListener('input', updateLensConfig);
            resetLensButton.addEventListener('click', resetLensSimulation);

            // Prism Simulator
            const prismCanvas = document.getElementById('prismCanvas');
            const prismCtx = prismCanvas.getContext('2d');

            const angleSlider = document.getElementById('angleSlider');
            const colorSlider = document.getElementById('colorSlider');
            const iorSlider = document.getElementById('iorSlider');
            const resetPrismButton = document.getElementById('resetPrismButton');

            const angleValue = document.getElementById('angleValue');
            const colorValue = document.getElementById('colorValue');
            const iorValue = document.getElementById('iorValue');
            const statusMessage = document.getElementById('statusMessage');

            const prism = {
                p1: { x: 300, y: 150 },
                p2: { x: 200, y: 300 },
                p3: { x: 400, y: 300 }
            };

            function drawPrism() {
                prismCtx.beginPath();
                prismCtx.moveTo(prism.p1.x, prism.p1.y);
                prismCtx.lineTo(prism.p2.x, prism.p2.y);
                prismCtx.lineTo(prism.p3.x, prism.p3.y);
                prismCtx.closePath();
                prismCtx.fillStyle = "rgba(76, 175, 80, 0.1)";
                prismCtx.strokeStyle = "rgba(76, 175, 80, 0.7)";
                prismCtx.lineWidth = 2;
                prismCtx.fill();
                prismCtx.stroke();
                
                // Draw angle indicators
                prismCtx.fillStyle = "#2d5a2d";
                prismCtx.font = "12px Arial";
                prismCtx.fillText("60¬∞", 295, 190);
                prismCtx.fillText("60¬∞", 245, 270);
                prismCtx.fillText("60¬∞", 345, 270);
            }

            function drawLightSource() {
                prismCtx.beginPath();
                prismCtx.arc(80, 200, 10, 0, 2 * Math.PI);
                prismCtx.fillStyle = "#d68c23";
                prismCtx.fill();
                prismCtx.closePath();
            }

            function drawWhiteLightBeam(angle) {
                const radians = angle * Math.PI / 180;
                const x1 = 80, y1 = 200;
                const dx = Math.cos(radians);
                const dy = Math.sin(radians);
                const x2 = x1 + dx * 400;
                const y2 = y1 + dy * 400;

                prismCtx.beginPath();
                prismCtx.moveTo(x1, y1);
                prismCtx.lineTo(x2, y2);
                prismCtx.strokeStyle = "rgba(214, 140, 35, 0.8)";
                prismCtx.lineWidth = 6;
                prismCtx.stroke();
                prismCtx.closePath();

                return lineIntersection({x: x1, y: y1}, {x: x2, y: y2}, prism.p1, prism.p2) ||
                       lineIntersection({x: x1, y: y1}, {x: x2, y: y2}, prism.p1, prism.p3);
            }

            function lineIntersection(p1, p2, p3, p4) {
                const denom = (p1.x - p2.x) * (p3.y - p4.y) -
                              (p1.y - p2.y) * (p3.x - p4.x);
                if (denom === 0) return null;

                const px = ((p1.x*p2.y - p1.y*p2.x) * (p3.x - p4.x) -
                           (p1.x - p2.x) * (p3.x*p4.y - p3.y*p4.x)) / denom;
                const py = ((p1.x*p2.y - p1.y*p2.x) * (p3.y - p4.y) -
                           (p1.y - p2.y) * (p3.x*p4.y - p3.y*p4.x)) / denom;

                if (px < Math.min(p1.x, p2.x) || px > Math.max(p1.x, p2.x) ||
                    px < Math.min(p3.x, p4.x) || px > Math.max(p3.x, p4.x) ||
                    py < Math.min(p1.y, p2.y) || py > Math.max(p1.y, p2.y)) {
                    return null;
                }
                return {x: px, y: py};
            }

            function refractRay(incident, normal, n1, n2) {
                const dot = incident.x * normal.x + incident.y * normal.y;
                const ratio = n1 / n2;
                const k = 1 - ratio * ratio * (1 - dot * dot);
                if (k < 0) return null;
                const rx = ratio * incident.x - (ratio * dot + Math.sqrt(k)) * normal.x;
                const ry = ratio * incident.y - (ratio * dot + Math.sqrt(k)) * normal.y;
                const len = Math.sqrt(rx * rx + ry * ry);
                return { x: rx / len, y: ry / len };
            }

            function findExitIntersection(start, dir, prism) {
                const rayEnd = { x: start.x + dir.x * 2000, y: start.y + dir.y * 2000 };

                const candidates = [
                    lineIntersection(start, rayEnd, prism.p2, prism.p3),
                    lineIntersection(start, rayEnd, prism.p1, prism.p3)
                ].filter(pt => pt);

                if (candidates.length === 0) return null;

                candidates.sort((a, b) => {
                    const da = (a.x - start.x) ** 2 + (a.y - start.y) ** 2;
                    const db = (b.x - start.x) ** 2 + (b.y - start.y) ** 2;
                    return da - db;
                });
                return candidates[0];
            }

            function wavelengthToColor(wavelength) {
                if (wavelength < 440) return "#8b5a2b"; // Violet -> brown
                if (wavelength < 490) return "#2c6b8b"; // Blue -> dark blue
                if (wavelength < 570) return "#2a8c55"; // Green -> dark green
                if (wavelength < 590) return "#d68c23"; // Yellow -> orange
                if (wavelength < 620) return "#c44b23"; // Orange -> red-orange
                return "#8b2c23"; // Red -> dark red
            }

            function drawRainbowLight(angle, baseIOR, entryPoint) {
                const radians = angle * Math.PI / 180;
                const dx = Math.cos(radians), dy = Math.sin(radians);
                const incident = { x: dx, y: dy };
                const normalEntry = { x: 0, y: -1 };

                const wavelengths = [400, 450, 500, 550, 600, 650, 700];

                wavelengths.forEach(wavelength => {
                    const ior = baseIOR + (700 - wavelength) * 0.0005;
                    const refractedDir1 = refractRay(incident, normalEntry, 1.0, ior);
                    if (!refractedDir1) return;

                    const exitPoint = findExitIntersection(entryPoint, refractedDir1, prism);
                    if (!exitPoint) return;

                    const normalExit = { x: 0, y: 1 };
                    const refractedDir2 = refractRay(refractedDir1, normalExit, ior, 1.0);
                    if (!refractedDir2) return;

                    const color = wavelengthToColor(wavelength);
                    prismCtx.beginPath();
                    prismCtx.moveTo(entryPoint.x, entryPoint.y);
                    prismCtx.lineTo(exitPoint.x, exitPoint.y);
                    prismCtx.strokeStyle = color;
                    prismCtx.lineWidth = 2;
                    prismCtx.stroke();
                    
                    prismCtx.beginPath();
                    prismCtx.moveTo(exitPoint.x, exitPoint.y);
                    prismCtx.lineTo(exitPoint.x + refractedDir2.x * 200, exitPoint.y + refractedDir2.y * 200);
                    prismCtx.strokeStyle = color;
                    prismCtx.lineWidth = 2;
                    prismCtx.stroke();
                });
            }

            function drawPrismScene() {
                const angle = parseFloat(angleSlider.value);
                const wavelength = parseInt(colorSlider.value);
                const baseIOR = parseFloat(iorSlider.value);
                prismCtx.clearRect(0, 0, prismCanvas.width, prismCanvas.height);

                drawPrism();
                drawLightSource();

                const entryPoint = drawWhiteLightBeam(angle);
                if (entryPoint) {
                    drawRainbowLight(angle, baseIOR, entryPoint);
                    statusMessage.textContent = "White light beam and rainbow dispersion visible.";
                } else {
                    statusMessage.textContent = "Light beam does not intersect the prism.";
                }

                angleValue.textContent = angle.toFixed(1) + "¬∞";
                colorValue.textContent = wavelength + " nm";
                iorValue.textContent = baseIOR.toFixed(2);
            }

            function resetPrismSimulation() {
                angleSlider.value = 25;
                colorSlider.value = 550;
                iorSlider.value = 1.5;
                drawPrismScene();
            }

            angleSlider.addEventListener("input", drawPrismScene);
            colorSlider.addEventListener("input", drawPrismScene);
            iorSlider.addEventListener("input", drawPrismScene);
            resetPrismButton.addEventListener("click", resetPrismSimulation);

            // Initialize both simulations
            updateLensConfig();
            drawPrismScene();
        });
    </script>
</body>
</html>