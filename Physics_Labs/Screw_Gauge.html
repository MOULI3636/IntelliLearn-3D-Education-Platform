<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screw Gauge (Micrometer) Simulation</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --main-color: #333;
            --secondary-color: #2e7d32;
            --border-color: #4caf50;
            --highlight-color: #4caf50;
            --white-color: #ffffff;
            --glow-color: rgba(76, 175, 80, 0.4);
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--bg-color);
            color: var(--main-color);
            margin: 0;
            padding: 20px;
            position: relative;
        }
        h1, h2 {
            color: var(--secondary-color);
            font-weight: 500;
            text-align: center;
            margin-bottom: 10px;
        }
        h1 {
            font-size: 2.2em;
            margin-top: 10px;
        }
        #simulation-wrapper {
            background-color: var(--white-color);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 0 20px var(--glow-color);
            margin-bottom: 20px;
            max-width: 900px;
            width: 100%;
            box-sizing: border-box;
            position: relative;
        }
        #screwGaugeCanvas {
            cursor: ew-resize;
            width: 100%;
            height: auto;
            border-radius: 8px;
        }
        #controls, #readings-display {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }
        button {
            background-color: var(--highlight-color);
            color: var(--white-color);
            border: none;
            padding: 10px 18px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            font-weight: 500;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        button:hover {
            background-color: #388e3c;
            transform: translateY(-2px);
        }
        button:active {
            transform: scale(0.98);
        }
        #readings-display span {
            font-size: 1.1em;
            background-color: #e8f5e9;
            padding: 8px 15px;
            border-radius: 5px;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            color: #2e7d32;
        }
        #output-table-container {
            width: 100%;
            max-width: 900px;
            margin-top: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background-color: var(--white-color);
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            border-radius: 8px;
            overflow: hidden;
        }
        th, td {
            border: 1px solid var(--border-color);
            padding: 12px;
            text-align: center;
        }
        th {
            background-color: #e8f5e9;
            font-weight: 600;
            color: var(--secondary-color);
        }
        tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        /* Theory Modal Styles */
        #theory-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 1000;
            overflow-y: auto;
        }
        #theory-content {
            position: relative;
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            width: 80%;
            max-width: 800px;
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0,0,0,0.3);
        }
        #close-theory {
            position: absolute;
            top: 15px;
            right: 15px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #theory-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: #2e7d32;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            z-index: 10;
        }
        #back-menu {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: #757575;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            z-index: 10;
        }
        
        /* Interactive elements */
        .interactive-hint {
            text-align: center;
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }
        .measurement-info {
            background-color: #e8f5e9;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }
        .measurement-info h3 {
            margin-top: 0;
            color: var(--secondary-color);
        }
    </style>
</head>
<body>

    <button id="theory-btn">Theory</button>
    <!-- <button id="back-menu">Back Menu</button> -->

    <h1>Screw Gauge (Micrometer) Simulation ⚙️</h1>
    <p class="interactive-hint">Drag the thimble or use buttons to rotate. Try inserting different objects!</p>

    <div id="simulation-wrapper">
        <canvas id="screwGaugeCanvas" width="900" height="300"></canvas>
        <div id="controls">
            <button id="insertObjectBtn">Insert Object</button>
            <button id="rotateMinusBtn" title="Rotate Anticlockwise (Unscrew)">Rotate Thimble –</button>
            <button id="rotatePlusBtn" title="Rotate Clockwise (Screw)">Rotate Thimble +</button>
            <button id="recordReadingBtn">Record Reading</button>
        </div>
        <div id="readings-display">
            <p><strong>Total Reading:</strong> <span id="totalReading">0.00 mm</span></p>
        </div>
        
        <div class="measurement-info">
            <h3>How to Read a Screw Gauge</h3>
            <p><strong>Pitch Scale Reading (PSR):</strong> Read the main scale value that's visible.</p>
            <p><strong>Circular Scale Reading (CSR):</strong> Find the division on the circular scale that aligns with the reference line.</p>
            <p><strong>Total Reading:</strong> PSR + (CSR × Least Count)</p>
            <p><strong>Least Count:</strong> Pitch / Number of divisions = 0.5 mm / 50 = 0.01 mm</p>
        </div>
    </div>
    
    <div id="output-table-container">
        <h2>Recorded Measurements</h2>
        <table id="measurementsTable">
            <thead>
                <tr>
                    <th>Object Name</th>
                    <th>Pitch Scale Reading (mm)</th>
                    <th>Circular Scale Reading (div x LC)</th>
                    <th>Total Measurement (mm)</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
    </div>

    <!-- Theory Modal -->
    <div id="theory-modal">
        <div id="theory-content">
            <button id="close-theory">×</button>
            <h2>Theory of Screw Gauge</h2>
            
            <h3>What is a Screw Gauge?</h3>
            <p>A screw gauge, also known as a micrometer, is a precision instrument used for measuring small dimensions with high accuracy, typically up to 0.01 mm or 0.001 inches.</p>
            
            <h3>Principle of Operation</h3>
            <p>The screw gauge works on the principle of a screw. When the thimble is rotated, the spindle moves linearly along the axis of rotation. The linear distance moved by the spindle for one complete rotation of the thimble is called the pitch of the screw.</p>
            
            <h3>Main Components</h3>
            <ul>
                <li><strong>Frame:</strong> The C-shaped body that holds the anvil and barrel.</li>
                <li><strong>Anvil and Spindle:</strong> The two surfaces between which the object is placed for measurement.</li>
                <li><strong>Barrel/Sleeve:</strong> The stationary part with the main scale (pitch scale) graduated in millimeters.</li>
                <li><strong>Thimble:</strong> The rotating part with the circular scale divided into 50 or 100 equal divisions.</li>
                <li><strong>Ratchet Stop:</strong> A device that applies a constant measuring pressure to prevent over-tightening.</li>
            </ul>
            
            <h3>How to Take a Reading</h3>
            <ol>
                <li>Place the object between the anvil and spindle.</li>
                <li>Gently rotate the thimble until the object is lightly gripped (use the ratchet for consistent pressure).</li>
                <li>Read the main scale value that is visible (Pitch Scale Reading - PSR).</li>
                <li>Read the circular scale division that aligns with the reference line on the main scale.</li>
                <li>Calculate the total reading using the formula: Total = PSR + (Circular Scale Reading × Least Count)</li>
            </ol>
            
            <h3>Least Count Calculation</h3>
            <p>The least count (LC) is the smallest measurement that can be taken with the instrument:</p>
            <p>LC = Pitch / Number of divisions on circular scale</p>
            <p>For a standard screw gauge with pitch = 0.5 mm and 50 divisions:</p>
            <p>LC = 0.5 mm / 50 = 0.01 mm</p>
            
            <h3>Zero Error</h3>
            <p>Zero error occurs when the zero of the circular scale does not coincide with the reference line when the anvil and spindle are in contact. It can be positive or negative and must be accounted for in precise measurements.</p>
            
            <h3>Applications</h3>
            <ul>
                <li>Measuring the diameter of wires and small spheres</li>
                <li>Measuring the thickness of sheets and plates</li>
                <li>Precision engineering and manufacturing</li>
                <li>Scientific experiments requiring high precision</li>
            </ul>
            
            <h3>Practice Exercise</h3>
            <p>Try measuring different objects in the simulation and record your readings. Compare your calculated measurements with the actual object sizes to practice using the screw gauge correctly.</p>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- SETUP ---
    const canvas = document.getElementById('screwGaugeCanvas');
    const ctx = canvas.getContext('2d');

    // DOM Elements
    const insertObjectBtn = document.getElementById('insertObjectBtn');
    const rotatePlusBtn = document.getElementById('rotatePlusBtn');
    const rotateMinusBtn = document.getElementById('rotateMinusBtn');
    const recordReadingBtn = document.getElementById('recordReadingBtn');
    const totalReadingEl = document.getElementById('totalReading');
    const tableBody = document.querySelector('#measurementsTable tbody');
    const theoryBtn = document.getElementById('theory-btn');
    const backMenuBtn = document.getElementById('back-menu');
    const theoryModal = document.getElementById('theory-modal');
    const closeTheoryBtn = document.getElementById('close-theory');

    // --- CONSTANTS & CONFIG ---
    const PITCH = 0.5; // mm per rotation
    const DIVISIONS = 50;
    const LEAST_COUNT = PITCH / DIVISIONS; // 0.01 mm
    const MAX_READING = 25; // mm
    const PIXELS_PER_MM = 28; // Scale factor for drawing

    const GAUGE_Y = 150; // Vertical center for the gauge
    const SLEEVE_START_X = 200;

    // --- STATE ---
    let spindlePosition = 4.78; // Current position in mm
    let objectSize = 0;
    let isObjectInserted = false;
    let objectNameCounter = 1;
    let isDragging = false;
    let lastMouseX = 0;
    let animationFrameId;

    // --- DRAWING FUNCTIONS ---
    const draw = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = '12px Arial';

        const thimblePositionX = SLEEVE_START_X + spindlePosition * PIXELS_PER_MM;
        
        drawFrame();
        drawAnvil();
        drawPitchScale();
        
        if (isObjectInserted) {
            drawObject();
        }

        drawSpindle(thimblePositionX);
        drawThimbleAndRatchet(thimblePositionX);
        drawLabels(thimblePositionX);
    };

    const drawFrame = () => {
        ctx.beginPath();
        ctx.moveTo(150, GAUGE_Y - 80);
        ctx.arc(100, GAUGE_Y, 80, -Math.PI / 2, Math.PI / 2);
        ctx.lineTo(150, GAUGE_Y + 80);
        ctx.lineWidth = 20;
        ctx.strokeStyle = '#7f8c8d';
        ctx.stroke();
    };

    const drawAnvil = () => {
        ctx.fillStyle = '#bdc3c7';
        ctx.fillRect(150, GAUGE_Y - 10, 30, 20);
    };

    const drawPitchScale = () => {
        const sleeveLength = MAX_READING * PIXELS_PER_MM + 20;
        // Sleeve body
        ctx.fillStyle = '#ecf0f1';
        ctx.fillRect(SLEEVE_START_X, GAUGE_Y - 12, sleeveLength, 24);
        ctx.strokeStyle = '#34495e';
        ctx.lineWidth = 1;
        ctx.strokeRect(SLEEVE_START_X, GAUGE_Y - 12, sleeveLength, 24);

        // Baseline
        ctx.beginPath();
        ctx.moveTo(SLEEVE_START_X, GAUGE_Y);
        ctx.lineTo(SLEEVE_START_X + sleeveLength, GAUGE_Y);
        ctx.stroke();

        // Markings
        ctx.fillStyle = '#34495e';
        for (let i = 0; i <= MAX_READING; i++) {
            const x = SLEEVE_START_X + i * PIXELS_PER_MM;
            // Millimeter marks (top)
            ctx.beginPath();
            ctx.moveTo(x, GAUGE_Y);
            ctx.lineTo(x, GAUGE_Y - 10);
            ctx.stroke();
            if (i % 5 === 0) {
                ctx.fillText(i, x - (i < 10 ? 3 : 7), GAUGE_Y - 14);
            }
            // Half-millimeter marks (bottom)
            if (i < MAX_READING) {
                const x_half = SLEEVE_START_X + (i + 0.5) * PIXELS_PER_MM;
                ctx.beginPath();
                ctx.moveTo(x_half, GAUGE_Y);
                ctx.lineTo(x_half, GAUGE_Y + 6);
                ctx.stroke();
            }
        }
    };

    const drawSpindle = (thimblePosX) => {
        const spindleStartX = 180;
        ctx.fillStyle = '#bdc3c7';
        ctx.fillRect(spindleStartX, GAUGE_Y - 5, thimblePosX - spindleStartX, 10);
    };

    const drawThimbleAndRatchet = (thimblePosX) => {
        const thimbleWidth = 150;
        const ratchetWidth = 40;
        // Thimble body
        ctx.fillStyle = '#ecf0f1';
        ctx.fillRect(thimblePosX, GAUGE_Y - 25, thimbleWidth, 50);
        ctx.strokeStyle = '#34495e';
        ctx.strokeRect(thimblePosX, GAUGE_Y - 25, thimbleWidth, 50);

        // Knurling on Thimble
        drawKnurling(thimblePosX + 60, GAUGE_Y, 90, 25);

        // Ratchet
        ctx.fillStyle = '#ecf0f1';
        ctx.fillRect(thimblePosX + thimbleWidth, GAUGE_Y - 15, ratchetWidth, 30);
        ctx.strokeRect(thimblePosX + thimbleWidth, GAUGE_Y - 15, ratchetWidth, 30);
        drawKnurling(thimblePosX + thimbleWidth, GAUGE_Y, ratchetWidth, 15);
        
        // Circular Scale Markings
        const remainder = spindlePosition % PITCH;
        const baseDivision = (DIVISIONS - Math.round(remainder / LEAST_COUNT)) % DIVISIONS;

        ctx.fillStyle = '#34495e';
        ctx.font = '11px Courier New';
        for (let i = -15; i <= 15; i++) {
            const division = (baseDivision + i + DIVISIONS) % DIVISIONS;
            const y = GAUGE_Y - i * 1.5; // Simple perspective
            const x = thimblePosX + 10;
            
            let tickLength = 5;
            if (division % 5 === 0) tickLength = 10;
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + tickLength, y);
            ctx.stroke();
            
            if (division % 5 === 0) {
                ctx.fillText(division, x + 15, y + 4);
            }
        }
    };

    const drawKnurling = (startX, y, width, radius) => {
        ctx.strokeStyle = '#95a5a6';
        ctx.lineWidth = 0.5;
        for (let i = 0; i < width; i += 5) {
            ctx.beginPath();
            ctx.moveTo(startX + i, y - radius);
            ctx.lineTo(startX + i + 10, y + radius);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(startX + i, y + radius);
            ctx.lineTo(startX + i + 10, y - radius);
            ctx.stroke();
        }
        ctx.lineWidth = 1; // Reset
    };

    const drawObject = () => {
        const objRadius = (objectSize * PIXELS_PER_MM) / 2;
        ctx.fillStyle = '#795548'; // Brown color for objects
        ctx.beginPath();
        ctx.arc(180 + objRadius, GAUGE_Y, objRadius, 0, 2 * Math.PI);
        ctx.fill();
        
        // Add a highlight to make the object more visible
        ctx.fillStyle = '#a1887f';
        ctx.beginPath();
        ctx.arc(180 + objRadius - objRadius/3, GAUGE_Y - objRadius/3, objRadius/4, 0, 2 * Math.PI);
        ctx.fill();
    };

    const drawLabels = (thimblePosX) => {
        ctx.fillStyle = 'black';
        ctx.font = '14px Arial';
        // Anvil/Stud
        drawArrow(165, GAUGE_Y - 40, 165, GAUGE_Y - 15, "Stud");
        // Frame
        drawArrow(100, GAUGE_Y + 110, 100, GAUGE_Y + 85, "Frame");
        // Screw/Spindle
        drawArrow(thimblePosX - 40, GAUGE_Y - 40, thimblePosX - 40, GAUGE_Y - 10, "Screw");
        // Pitch Scale
        drawArrow(SLEEVE_START_X + 50, GAUGE_Y - 50, SLEEVE_START_X + 50, GAUGE_Y - 15, "Pitch scale");
        // Circular Scale
        drawArrow(thimblePosX + 30, GAUGE_Y - 60, thimblePosX + 30, GAUGE_Y - 30, "Circular scale");
        // Thimble
        drawArrow(thimblePosX + 100, GAUGE_Y + 60, thimblePosX + 100, GAUGE_Y + 30, "Thimble");
        // Ratchet
        drawArrow(thimblePosX + 170, GAUGE_Y + 40, thimblePosX + 170, GAUGE_Y + 18, "Ratchet");
    };

    const drawArrow = (fromX, fromY, toX, toY, text) => {
        const headlen = 8;
        const angle = Math.atan2(toY - fromY, toX - fromX);
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(toX, toY);
        ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
        ctx.strokeStyle = '#34495e';
        ctx.stroke();
        ctx.fillText(text, fromX - 20, fromY - 8);
    };

    // --- LOGIC FUNCTIONS ---
    const updateSpindlePosition = (newValue) => {
        const minPos = isObjectInserted ? objectSize : 0;
        if (newValue >= minPos && newValue <= MAX_READING) {
            spindlePosition = newValue;
             // Snap to nearest least count
            spindlePosition = Math.round(spindlePosition / LEAST_COUNT) * LEAST_COUNT;
            return true;
        } else if (newValue < minPos) {
            spindlePosition = minPos;
        }
        return false;
    };
    
    const calculateReadings = () => {
        const pos = spindlePosition;
        const mainScaleReading = Math.floor(pos);
        const subScaleReading = Math.floor((pos - mainScaleReading) / PITCH) * PITCH;
        const psr = mainScaleReading + subScaleReading;

        const circularScaleValue = pos - psr;
        let coincidingDivision = Math.round(circularScaleValue / LEAST_COUNT);
        if(coincidingDivision === 50) coincidingDivision = 0; // Wrap around 49->0

        const csr = coincidingDivision * LEAST_COUNT;
        const total = psr + csr;

        return {
            psr: psr.toFixed(2),
            csrText: `${coincidingDivision} x ${LEAST_COUNT.toFixed(2)} = ${csr.toFixed(2)}`,
            total: total.toFixed(2)
        };
    };

    const updateDisplay = () => {
        const readings = calculateReadings();
        totalReadingEl.textContent = `${readings.total} mm`;
    };

    const animate = () => {
        draw();
        updateDisplay();
        animationFrameId = requestAnimationFrame(animate);
    };

    // --- EVENT HANDLERS ---
    insertObjectBtn.addEventListener('click', () => {
        if (isObjectInserted) {
            isObjectInserted = false;
            objectSize = 0;
            insertObjectBtn.textContent = 'Insert Object';
        } else {
            isObjectInserted = true;
            // Generate smaller objects (1mm to 5mm) to prevent overlapping
            objectSize = parseFloat((Math.random() * 4 + 1).toFixed(2));
            updateSpindlePosition(objectSize + 0.5); // Move spindle away to fit object
            insertObjectBtn.textContent = `Remove Object (${objectSize} mm)`;
        }
    });

    rotatePlusBtn.addEventListener('click', () => updateSpindlePosition(spindlePosition - LEAST_COUNT));
    rotateMinusBtn.addEventListener('click', () => updateSpindlePosition(spindlePosition + LEAST_COUNT));

    recordReadingBtn.addEventListener('click', () => {
        const readings = calculateReadings();
        const newRow = tableBody.insertRow();
        newRow.innerHTML = `
            <td>Object ${objectNameCounter} ${isObjectInserted ? `(${objectSize} mm)`: ''}</td>
            <td>${readings.psr}</td>
            <td>${readings.csrText}</td>
            <td><strong>${readings.total}</strong></td>
        `;
        objectNameCounter++;
    });

    // Theory modal handlers
    theoryBtn.addEventListener('click', () => {
        theoryModal.style.display = 'block';
    });
    
    closeTheoryBtn.addEventListener('click', () => {
        theoryModal.style.display = 'none';
    });
    
    window.addEventListener('click', (e) => {
        if (e.target === theoryModal) {
            theoryModal.style.display = 'none';
        }
    });
    
    backMenuBtn.addEventListener('click', () => {
        alert('Back to main menu - This would typically navigate to the main menu page.');
    });

    // Mouse drag controls
    canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastMouseX = e.offsetX;
        canvas.style.cursor = 'grabbing';
    });
    
    window.addEventListener('mouseup', () => {
        isDragging = false;
        canvas.style.cursor = 'ew-resize';
    });

    window.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const deltaX = e.offsetX - lastMouseX;
        // Sensitivity: 1 pixel move = 0.01 mm change
        const deltaPos = -deltaX * 0.01;
        updateSpindlePosition(spindlePosition + deltaPos);
        lastMouseX = e.offsetX;
    });

    // --- INITIALIZATION ---
    animate();
});
</script>

</body>
</html>